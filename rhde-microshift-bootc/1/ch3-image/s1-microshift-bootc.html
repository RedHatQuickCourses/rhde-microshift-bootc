<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>RHEL Image Mode With MicroShift :: Deploying MicroShift on RHEL Image Mode</title>
    <link rel="prev" href="index.html">
    <link rel="next" href="s2-image-lab.html">
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">Deploying MicroShift on RHEL Image Mode</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/rhde-microshift-bootc/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="rhde-microshift-bootc" data-version="1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Deploying MicroShift on RHEL Image Mode</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">Home</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch1-microshift/index.html">Introduction to Red Hat Build of MicroShift</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-microshift/s1-microshift-vs-ocp.html">Introduction to MicroShift and Red Hat Device Edge</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-microshift/s2-prepare-lab.html">Lab: Prepare a Test Environment for Image Mode and MicroShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-microshift/s3-air-gapped-lab.html">Lab: Prepare a Disconnected Environment for MicroShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch1-microshift/s4-summary.html">Summary</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../ch2-package/index.html">Deploy MicroShift on RHEL Servers</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-package/s1-install-config.html">Install and Configure MicroShift on Package-Based RHEL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-package/s2-install-lab.html">Lab: Install MicroShift from RPM Packages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-package/s3-access-lab.html">Lab: Access MicroShift as a Developer or Platform Engineer</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-package/s4-apps-lab.html">Lab: Deploy Kubernetes Applications in MicroShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../ch2-package/s5-summary.html">Summary</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Deploy MicroShift on RHEL Image Mode</a>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="s1-microshift-bootc.html">RHEL Image Mode With MicroShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s2-image-lab.html">Lab: Create Bootc Container Images with MicroShift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="s4-summary.html">Summary</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Deploying MicroShift on RHEL Image Mode</span>
    <span class="version">1</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../rhde-microshift/1/index.html">Deploying MicroShift on Red Hat Device Edge</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../rhde-microshift/1/index.html">1</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../index.html">Deploying MicroShift on RHEL Image Mode</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../samples/1/index.html">samples</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../samples/1/index.html">1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Deploying MicroShift on RHEL Image Mode</a></li>
    <li><a href="index.html">Deploy MicroShift on RHEL Image Mode</a></li>
    <li><a href="s1-microshift-bootc.html">RHEL Image Mode With MicroShift</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">RHEL Image Mode With MicroShift</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><em>Estimated reading time: <strong>12 minutes</strong>.</em></p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Objective</dt>
<dd>
<p>Deploy MicroShift on RHEL image mode by building bootc container images and custom installation ISOs.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_microshift_on_bootc_container_images"><a class="anchor" href="#_microshift_on_bootc_container_images"></a>MicroShift on Bootc Container Images</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Deploying MicroShift using image mode is not different than adding any other application to a bootc container image.
You could include MicroShift with a complete set of configuration files already embedded in a bootc image; or you could include just MicroShift packages and add configuration files after installation, as part of an on-boarding process or other day-2 activity.</p>
</div>
<div class="paragraph">
<p>But, before we drive into the specifics of including MicroShift in bootc container images for air-gapped environments, let&#8217;s consider how image mode deployments differ than traditional package mode deployments and the most common ways that organizations use approach image mode deployments.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_application_versus_device_or_opearting_system_lifecycles"><a class="anchor" href="#_application_versus_device_or_opearting_system_lifecycles"></a>Application versus Device or Opearting System Lifecycles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When you plan a deployment of MicroShift on edge devices, you must consider the lifecycles of devices and their applications. It is never just MicroShift. The sole purpose of MicroShift is to support Kubernetes applications, which are deployed from container images and resource manifests.</p>
</div>
<div class="paragraph">
<p>Organizations deploying MicroShift and Kubernetes applications on their edge devices adopt different approaches, depending on how much they want to preserve their existing processes and workflows that already work for their data center servers and office computers and how mature they are on their modernization and DevOps journeys.</p>
</div>
<div class="paragraph">
<p>On one side, organizations want to keep the lifecycles of the operating systems (OS) separate from the lifecycle of their applications.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../rhde-microshift/1/ch3-image/_images/s1-edge-fig-1.svg" alt="s1 edge fig 1">
</div>
<div class="title">Figure 1. Tools and activities in a traditional edge device and application lifecycle</div>
</div>
<div class="paragraph">
<p>These organizations usually have different teams that own OS and applications and use different tools for managing them. On day one, one team deploys and configures the operating system on edge devices; on day two, another team deploys and configures applications on those devices.</p>
</div>
<div class="paragraph">
<p>On the other side, organizations want to adopt a "shift left" approach and minimize the work to be performed on day one and day two and have the operating system and its applications preconfigured by the installation media.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/s1-edge-fig-2.svg" alt="s1 edge fig 2">
</div>
<div class="title">Figure 2. Tools and activities in a shift-left edge device and application lifecycle</div>
</div>
<div class="paragraph">
<p>These organizations usually have the same DevOps team owning both applications and their supporting operating system, while another team, such as the Operational Technology team, provisions edge devices which are practically ready to use after provisioning, with minimal configuration to perform on day two. But that other team is not usually granted with system administrator rights to the edge devices.</p>
</div>
<div class="sect2">
<h3 id="_distinct_lifecycles_for_os_and_applications_keep_it_the_way_we_are_used_to"><a class="anchor" href="#_distinct_lifecycles_for_os_and_applications_keep_it_the_way_we_are_used_to"></a>Distinct Lifecycles for OS and Applications: Keep It The Way We Are Used To</h3>
<div class="paragraph">
<p>Some organizations prefer to keep separate lifecycles for the operating system and applications on their edge devices. This meets their team structure and enables separation of concerns, but requires that edge devices have good enough access to container image registries, RPM repositories, and also Git repositories, if employing popular GitOps techniques.</p>
</div>
<div class="paragraph">
<p>To NOT shift left has the advantage of keeping processes for provisioning and managing edge devices closer to the processes already used for data center servers and office workstations. This may be appropriate for edge sites that have their own IT infrastructure, which it is similar to corporate sites, and for edge sites that have reliable and fast network connectivity to corporate sites.</p>
</div>
<div class="paragraph">
<p>Both the RHEL for Edge tooling (RPM-OSTree) and the RHEL image mode tooling (bootc) supports that approach, by allowing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Activation of a <code>/usr</code> overlay to install additional packages.</p>
</li>
<li>
<p>Pull container images from container image registries.</p>
</li>
<li>
<p>Remote access to the Kubernetes API endpoints of individual edge devices running MicroShift.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Organizations following that approach typically consider MicroShift as part of the OS, and build system images which are minimally configured for the edge site and corporate networks. Then they deploy applications using Kubernetes manifests, helm charts, and container registries like they would for servers in their data centers.</p>
</div>
<div class="paragraph">
<p>These organizations could use the same system image for all devices and sites, independent of the applications to be deployed on each, or have only a few different system images to account for specific hardware and different OS releases.</p>
</div>
</div>
<div class="sect2">
<h3 id="_shift_left_do_it_all_at_image_build_time"><a class="anchor" href="#_shift_left_do_it_all_at_image_build_time"></a>Shift Left: Do It All At Image Build Time</h3>
<div class="paragraph">
<p>Some organizations embrace the "shift left" approach, and wish to perform as many tasks as possible during day zero, that is, at image build time. Both the RHEL for Edge tooling (RPM-OSTree) and the RHEL image mode tooling (bootc) were designed to support that approach, by enabling embedding multiple artifacts in an edge system image, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Custom RPM packages, from private RPM repositories.</p>
</li>
<li>
<p>Container images, which are preloaded in the local container engine.</p>
</li>
<li>
<p>Configuration files and scripts.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you need to include too many files, larger files, or binary files, which are not convenient to manage as blueprint customizations for RPM-OStree or Container file instructions for bootc, you should consider creating custom RPM packages, as described by <a href="https://www.redhat.com/en/blog/how-to-create-a-fully-self-contained-os-image-that-includes-your-kubernetes-workload">How to create a fully self-contained OS image that includes your Kubernetes workload</a>. That is usually the case for Kubernetes application manifests.</p>
</div>
<div class="paragraph">
<p>Not everything can be done, or should be done, at day zero. There will be always some configuration that you wish to perform at installation time (day one) or later, to mitigate security concerns or to address variability between different edge sites or even individual edge devices.</p>
</div>
<div class="paragraph">
<p>As a recommended practice, you should not embed into edge system images anything that could be used to access other systems with write privileges, and you should consider carefully the risk of having credentials that allow read access embedded in a system image. You should plan day-1 processes to incorporate those credentials into your edge systems in a secure way.</p>
</div>
<div class="paragraph">
<p>For example, it is probably fine to embed the public key of a corporate certificate authority (CA) or pull secrets for downloading container images from a private registry. But it is <strong>NOT</strong> fine embedding credentials to access a corporate or site database, not even credentials with privileges to execute only queries, because of the risk of information leakage.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rhel_image_mode_image_building_and_deployment_workflow"><a class="anchor" href="#_rhel_image_mode_image_building_and_deployment_workflow"></a>RHEL Image Mode Image Building and Deployment Workflow</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In any case (shift left or not), there are benefits in building bootc container images which include pre-configured MicroShift instances.
You decide how much you will preconfigure, from offering an empty MicroShift instance, which is ready for remote access as a cluster administrator, to offering a MicroShift instance with multiple workloads already deployed.</p>
</div>
<div class="paragraph">
<p>As a reminder, the following figure depicts the overall workflow for building bootc container images and deploying them on edge devices, using RHEL image mode.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/s1-edge-fig-3.svg" alt="s1 edge fig 3">
</div>
<div class="title">Figure 3. Workflow for building and deploying bootc container images on edge devices</div>
</div>
<div class="paragraph">
<p>If your edge deployment is air-gapped, it is recommended that you use an custom installation ISO, which you can write to USB media or serve from a network boot server.
If that image already embeds all your applications and configurations, it can provision devices without access to other network services, such as container image registries.</p>
</div>
<div class="paragraph">
<p>To build an custom installation ISO, you must first build a bootc container image, using Podman or any tool capable of creating OCI container images, and then use the <strong>bootc image builder</strong> tool, which creates the installation ISO from a bootc container image stored locally plus an image builder blueprint, which provides Kickstart instructions for installation time.</p>
</div>
<div class="paragraph">
<p>If you need a refresher on the finer details or troubleshooting hints for building bootc container images and using bootc image builder, please review the following RHEL labs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.redhat.com/en/introduction-to-image-mode-for-red-hat-enterprise-linux-interactive-lab" target="_blank" rel="noopener">Introduction to image mode for Red Hat Enterprise Linux</a></p>
</li>
<li>
<p><a href="https://www.redhat.com/en/day-2-operations-with-image-mode-for-red-hat-enterprise-linux" target="_blank" rel="noopener">Day 2 operations with image mode for Red Hat Enterprise Linux</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_air_gapped_builds_with_private_container_registries"><a class="anchor" href="#_air_gapped_builds_with_private_container_registries"></a>Air-Gapped Builds With Private Container Registries</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Many organizations do not allow edge devices to download content, especially software, from the Internet.
They must download all content from secure internal servers.
That means all software, such as RPM packages and container images, must be provided by servers owned by your organization.
This is commonly referred to as air-gapped operations.</p>
</div>
<div class="paragraph">
<p>Such organizations usually place similar constraints on corporate servers and development systems.
You would be required to configure your developer workstations and CI/CD servers to fetch all software from internal servers instead of from the Internet, that is, to build bootc container images while operating air-gapped.</p>
</div>
<div class="paragraph">
<p>Notice that supporting air-gapped bootc container image builds and air-gapped edge device provisioning present different caveats.
Developer workstations and CI/CD servers usually runs at a corporate site, with high speed and reliable access to package servers and container registries.
Sometimes edge devices have good network connectivity to these corporate services, or they can rely on a local mirrors at their edge sites.
But your edge devices might not have good enough connectivity to those services and would consequently require that you include all artifacts, including all application container images, in their bootc container images.</p>
</div>
<div class="paragraph">
<p>Most Linux system administrators are used to the process of configuring RPM package servers and package repository mirrors, either using supported software such as Red Hat Satellite or by configuring their own web servers and using the <code>rpmsync</code> command.
However many system administrators are not used to configure container image registries and container image mirrors.</p>
</div>
<div class="paragraph">
<p>When you build OCI containers using Podman it takes subscription entitlements from the host system, so they can download RPM packages from Red Hat servers, but they do not inherit the DNF configuration from their host system to access corporate package repository servers.
In that case, you must copy DNF repository configuration files to your OCI container image, before you include any <code>RUN</code> statement that installs RPM packages on your containerfile.</p>
</div>
<div class="paragraph">
<p>Similarly, you can copy registry configuration files for the local container engine, as part of your containerfile, and them use those configurations to pull container images from corporate image registry servers, during your container image build, and embed those application container images inside a bootc container image.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_physically_bound_containers"><a class="anchor" href="#_using_physically_bound_containers"></a>Using Physically Bound Containers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>What RHEL image mode documentation call <strong>physically bound containers</strong> are just container image layers that are stored, as regular files, in a bootc container image.</p>
</div>
<div class="paragraph">
<p>If you run your application containers directly from Podman, or using Quadlets, you can specify the read-only directory storing those layers as an alternate container image storage for your containers.
Unfortunately Kubernetes pod cannot specify their own container storage.</p>
</div>
<div class="paragraph">
<p>If all pods you run would be embedded in your boot container image, considering both pods required my MicroShift itself and also your application pods, you could theoretically configure CRI-O to use an alternate, read-only location for its container storage.
That would prevent running additional pods, which are commonly required for troubleshooting, such as must-gather containers, unless you also add such containers to your bootc container image.</p>
</div>
<div class="paragraph">
<p>It would theoretically be possible to configure an alternate read-only container storage only for Kubernetes static pods, and thus include only MicroShift pods in your bootc container images, but pull application containers dynamically, from a remote container registry, to writable container storage.
That won&#8217;t work if any of your application containers share any layers with any of your static pods, which is quite common when containers share base images and programming language runtimes from RHEL.</p>
</div>
<div class="paragraph">
<p>Using additional (or alternate) container storage for containers also presents issues regarding system updates: you must ensure you destroy old containers and start new containers, to prevent any dangling references to outdated image layers that would not exist in the new system image anymore.
MicroShift, as any other Kubernetes, would not recreate application pods (and their containers) on reboot and updates.</p>
</div>
<div class="paragraph">
<p>The recommended approach, to avoid any issues with physically bound containers, is a two-step process:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Copy container image layers to your bootc container image, at build time.
Notice this is NOT a pull operation, because you don&#8217;t want to save those layers to the ephemeral container storage of your image build.</p>
</li>
<li>
<p>Copy your container image layers from the read-only system image to the writable system container storage, at boot time, so they look like layers that are already pulled when you start containers using them.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The first step becomes an <code>skopeo copy</code> command in your containerfile.
The second step becomes either a first-boot Systemd unit or a Systemd drop-in file for the MicroShift service unit, any of which you create as part of your containerfile.</p>
</div>
<div class="paragraph">
<p>This approach enables maximum flexibility: it gives you freedom to include just MicroShift container images, add selected application images, or even all container images you could possibly need for troubleshooting in your bootc container, at day-0; and still keep the ability of pulling new container images on day-1 and day-2, for additional troubleshooting tools or to test application updates, without having to build new bootc container images.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_whats_next"><a class="anchor" href="#_whats_next"></a>What&#8217;s Next</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The next and final activity of this course shows a containerfile which configures a MicroShift instance and embeds all required configuration files and container images, and builds an installer ISO with a custom kickstart file for unattended installation.
At image build time, you use local RPM repositories and a mirror registry, without requiring access to Red Hat servers over the Internet, and then you provision an edge device from your installation ISO without accessing any RPM repository nor container registry server.</p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="index.html">Deploy MicroShift on RHEL Image Mode</a></span>
  <span class="next"><a href="s2-image-lab.html">Lab: Create Bootc Container Images with MicroShift</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
